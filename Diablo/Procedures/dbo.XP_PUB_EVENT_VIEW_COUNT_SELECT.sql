USE [Diablo]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*================================================================================================================
■ USP_NAME					: XP_PUB_EVENT_VIEW_COUNT_SELECT
■ DESCRIPTION				: 기획전 상세 정보
■ INPUT PARAMETER			: 
■ EXEC						: 

	EXEC XP_PUB_EVENT_VIEW_COUNT_SELECT 6865, '2017-03-01', '2018-04-30'

■ MEMO						: 
------------------------------------------------------------------------------------------------------------------
■ CHANGE HISTORY                   
------------------------------------------------------------------------------------------------------------------
   DATE				AUTHOR			        DESCRIPTION           
------------------------------------------------------------------------------------------------------------------
   2018-03-27		김성호					최초생성
================================================================================================================*/ 
CREATE PROCEDURE [dbo].[XP_PUB_EVENT_VIEW_COUNT_SELECT]
	@EVT_SEQ	INT,
	@START_DATE	DATE,
	@END_DATE	DATE
AS
BEGIN

	DECLARE @SQLSTRING NVARCHAR(MAX) = '', @PARMDEFINITION NVARCHAR(1000) = '', @DATE_STRING NVARCHAR(MAX) = '';

	-- 마지막 날짜가 오늘을 넘지 않도록
	IF @END_DATE > GETDATE()
		SET @END_DATE = GETDATE();

	-- PIVOT 문자열
	SELECT @DATE_STRING = SUBSTRING(CONVERT(NVARCHAR(4000), (
		SELECT (',' + A.FLAG) AS [text()]
		FROM (
			SELECT '[' + CONVERT(VARCHAR(4), YEAR(A.DATE)) + '년' + RIGHT(('0' + CONVERT(VARCHAR(2), MONTH(A.DATE))), 2) + '월'
				+ CONVERT(VARCHAR(1), ROW_NUMBER() OVER (PARTITION BY YEAR(A.DATE), MONTH(A.DATE) ORDER BY A.DATE)) + '주]' AS [FLAG]
			FROM [DBO].[PUB_TMP_DATE] A WITH(NOLOCK)
			WHERE A.DATE >= @START_DATE AND A.DATE < @END_DATE AND WEEK_DAY = 1
		) A
		FOR XML PATH('')
	)) + ',[합계]', 2, 4000)

	SET @SQLSTRING = N'
	-- 이벤트 정보
	SELECT *
	FROM Diablo.DBO.PUB_EVENT A WITH(NOLOCK) WHERE EVT_SEQ = @EVT_SEQ;

	-- 주별 뷰 카운트
	WITH EVT_LIST AS (
		SELECT *
		FROM (
			SELECT B.EVT_SEQ, ISNULL((A.YEAR + ''년'' + A.MONTH + ''월'' + A.WEEK_NUM + ''주''), ''합계'') AS [DATE_INFO], SUM(B.WEEK_COUNT) AS [WEEK_COUNT]
			FROM (
				SELECT A.DATE, A.WEEK_DAY, CONVERT(VARCHAR(4), YEAR(A.DATE)) AS [YEAR], RIGHT((''0'' + CONVERT(VARCHAR(2), MONTH(A.DATE))), 2) AS [MONTH]
					, CONVERT(VARCHAR(1), ROW_NUMBER() OVER (PARTITION BY YEAR(A.DATE), MONTH(A.DATE) ORDER BY A.DATE)) AS [WEEK_NUM]
				FROM [DBO].[PUB_TMP_DATE] A WITH(NOLOCK)
				WHERE A.DATE >= @START_DATE AND A.DATE < @END_DATE AND WEEK_DAY = 1
			) A
			INNER JOIN VGLOG.DBO.PUB_EVENT_READ_COUNT B WITH(NOLOCK) ON A.DATE = B.READ_DATE-- AND B.WEEK_COUNT > @LIMIT_COUNT
			WHERE B.EVT_SEQ = @EVT_SEQ
			GROUP BY GROUPING SETS (((A.YEAR + ''년'' + A.MONTH + ''월'' + A.WEEK_NUM + ''주''), B.EVT_SEQ, WEEK_COUNT)
				, (B.EVT_SEQ))
		) A
		PIVOT (
			SUM(A.WEEK_COUNT) FOR A.DATE_INFO IN (' + @DATE_STRING + N')
		) AS [PVT]
	)
	SELECT A.EVT_SEQ AS [코드], B.EVT_NAME AS [기획전명], CONVERT(VARCHAR(10), B.START_DATE, 120) AS [시작], CONVERT(VARCHAR(10), B.END_DATE, 120) AS [종료], CONVERT(VARCHAR(10), B.NEW_DATE, 120) AS [등록일], ' + @DATE_STRING + N'
	FROM EVT_LIST A
	LEFT JOIN Diablo.DBO.PUB_EVENT B WITH(NOLOCK) ON A.EVT_SEQ = B.EVT_SEQ;

	-- 상품 예약자 카운트
	WITH LIST AS (
		SELECT A.DATE, CONVERT(VARCHAR(4), YEAR(A.DATE)) AS [YEAR], RIGHT((''0'' + CONVERT(VARCHAR(2), MONTH(A.DATE))), 2) AS [MONTH]
			, ROW_NUMBER() OVER (ORDER BY A.DATE) AS [DATE_SEQ] 
			, CONVERT(VARCHAR(1), ROW_NUMBER() OVER (PARTITION BY YEAR(A.DATE), MONTH(A.DATE) ORDER BY A.DATE)) AS [WEEK_NUM]
		FROM DBO.PUB_TMP_DATE A WITH(NOLOCK)
		WHERE A.DATE > = DATEADD(D, -7, @START_DATE) AND A.DATE < @END_DATE AND A.WEEK_DAY = 1
	)
	, DATE_LIST AS (
		SELECT B.DATE AS [START_DATE], ISNULL(A.DATE, @END_DATE) AS [END_DATE]
			, C.MASTER_CODE, C.PRO_CODE
			, (A.YEAR + ''년'' + A.MONTH + ''월'' + A.WEEK_NUM + ''주'') AS [DATE_INFO]
		FROM LIST A
		LEFT JOIN LIST B ON (A.DATE_SEQ - 1) = B.DATE_SEQ
		CROSS JOIN Diablo.DBO.PUB_EVENT_DATA C
		WHERE C.EVT_SEQ = @EVT_SEQ AND C.SHOW_YN = ''Y'' AND B.DATE IS NOT NULL AND C.MASTER_CODE IS NOT NULL
	)
	, TOTAL_LIST AS
	(
		SELECT A.CODE, ISNULL(A.DATE_INFO, ''합계'') AS [DATE_INFO], SUM(ISNULL(A.RES_COUNT, 0)) AS [RES_COUNT]
		FROM (
			SELECT A.MASTER_CODE AS [CODE], A.DATE_INFO, COUNT(*) AS [RES_COUNT]
			FROM DATE_LIST A
			INNER JOIN Diablo.DBO.RES_MASTER_damo B WITH(NOLOCK) ON A.MASTER_CODE = B.MASTER_CODE AND B.NEW_DATE >= A.START_DATE AND B.NEW_DATE < A.END_DATE AND B.RES_STATE <> 8
			INNER JOIN Diablo.DBO.RES_CUSTOMER_damo C WITH(NOLOCK) ON B.RES_CODE = C.RES_CODE AND C.RES_STATE <> 8
			--WHERE A.PRO_CODE IS NULL
			GROUP BY A.MASTER_CODE, A.END_DATE, A.DATE_INFO
			--UNION
			--SELECT A.PRO_CODE, A.DATE_INFO, COUNT(*) AS [RES_COUNT]
			--FROM DATE_LIST A
			--INNER JOIN Diablo.DBO.RES_MASTER_damo B WITH(NOLOCK) ON A.PRO_CODE = B.PRO_CODE AND B.NEW_DATE >= A.START_DATE AND B.NEW_DATE < A.END_DATE AND B.RES_STATE <> 8
			--INNER JOIN Diablo.DBO.RES_CUSTOMER_damo C WITH(NOLOCK) ON B.RES_CODE = C.RES_CODE AND C.RES_STATE <> 8
			--WHERE A.MASTER_CODE IS NULL
			--GROUP BY A.PRO_CODE, A.END_DATE, A.DATE_INFO
		) A
		GROUP BY  GROUPING SETS ((A.DATE_INFO, A.CODE, A.RES_COUNT)
			, (A.CODE))
	)
	--SELECT *
	SELECT PVT.CODE AS [마스터코드], ' + @DATE_STRING + N'
	FROM TOTAL_LIST A
	PIVOT (
		SUM(A.RES_COUNT) FOR A.DATE_INFO IN (' + @DATE_STRING + N')
	) AS [PVT]
'

	--PRINT @SQLSTRING;

	SET @PARMDEFINITION = N'
		@EVT_SEQ INT,
		@START_DATE DATE, 
		@END_DATE DATE';

	EXEC SP_EXECUTESQL @SQLSTRING, @PARMDEFINITION, 
		@EVT_SEQ,
		@START_DATE, 
		@END_DATE;

END
GO
