USE [Diablo]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		<문태중>
-- Create date: <2008-04-18>
-- Description:	<개인 일정을 반복된 일수/주/달수로 삽입 및 수정한다>
-- 2011-10-04 예약고객약속안내추가 SCH_TYPE = 9 , 예약코드 추가 
-- 2011-10-14 상품담당자 예약넣을때 조건 추가 
-- =============================================
CREATE PROCEDURE [dbo].[SP_PRI_SCHEDULE_INSERT]
	@QTYPE			CHAR(1),
	@EMP_CODE		VARCHAR(10),
	@SCH_TYPE		CHAR(1),
	@SCH_DATE		DATETIME,
	@RPT_TYPE		INT,
	@SUBJECT		VARCHAR(50),
	@CONTENTS		VARCHAR(400),
	@FONT_COLOR		VARCHAR(20),
	@SCH_GRADE		CHAR(1),
	@ALT_TIME		DATETIME,
	@ALT_YN			CHAR(1),	
	@START_TIME		DATETIME,
	@END_TIME		DATETIME,	
	@USERID			VARCHAR(20),
	@USERNAME		VARCHAR(20),
	@SEQ			INT,
	@PARENT_SEQ		INT,
	@RES_CODE		RES_CODE
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @TMP_SEQ INT; --시퀀스 넘버
	DECLARE @REPEATCOUNT INT;  --반복 일수
	DECLARE @RPT_DAYCOUNT INT;   --반복 타입 1 : 1일 / 2:월~금 / 3:매주(+7) / 4:매월(+MONTH)
	
	
	IF @QTYPE = 'U'  --수정일 경우 기존 데이터 삭제
	BEGIN		
		SELECT @TMP_SEQ = PARENT_SEQ FROM PRI_SCHEDULE WITH(NOLOCK) WHERE EMP_CODE = @EMP_CODE AND SEQ_NO = @SEQ;
		IF ( ISNULL(@RES_CODE,'') = '')  -- 수정일 경우 기존 예약번호 다시 담기 
		BEGIN
			SELECT @RES_CODE = RES_CODE FROM PRI_SCHEDULE WITH(NOLOCK) WHERE EMP_CODE = @EMP_CODE AND SEQ_NO = @SEQ;
		END 
		
		DELETE FROM PRI_SCHEDULE WHERE PARENT_SEQ = @TMP_SEQ;	
	END	
		
	SET @REPEATCOUNT = DATEDIFF(DAY,@START_TIME, @SCH_DATE);
	IF @REPEATCOUNT = 0  -- 반복없음
	BEGIN				
	
		--ERP 예약정보수정(예약자) 탭 에서 사용 
		--상품담당자로 한번더 스케쥴을 넣을때 기존 예약스케쥴이 있으면 수정 한다 .  2011-10-14
		IF( ISNULL(@RES_CODE,'') <> '' AND @QTYPE = 'I'
			AND EXISTS(SELECT * FROM PRI_SCHEDULE WITH(NOLOCK) WHERE RES_CODE = @RES_CODE AND EMP_CODE = @EMP_CODE )
		)
		BEGIN
		
			DECLARE @UPD_SEQ_NO INT 
			SET @UPD_SEQ_NO = 
				( SELECT TOP 1 SEQ_NO FROM PRI_SCHEDULE WITH(NOLOCK) WHERE RES_CODE = @RES_CODE AND EMP_CODE = @EMP_CODE ORDER BY SEQ_NO DESC ) 
		
			UPDATE PRI_SCHEDULE 
			SET SCH_DATE = @SCH_DATE 
				, SUBJECT = @SUBJECT 
				, CONTENTS = @CONTENTS 
				, ALT_TIME = @ALT_TIME 
				, ALT_YN = @ALT_YN
				, FONT_COLOR = @FONT_COLOR 
				, START_TIME = @START_TIME 
				, END_TIME = @END_TIME 
				, EDT_CODE = @USERID
				, EDT_NAME = @USERNAME
				, EDT_DATE = GETDATE()
			WHERE SEQ_NO = @UPD_SEQ_NO 
		END 
		ELSE 
		BEGIN
			INSERT INTO PRI_SCHEDULE
			(
			EMP_CODE,		SCH_TYPE,		SCH_DATE,		SUBJECT,		CONTENTS,
			SCH_GRADE,		ALT_TIME,		ALT_YN,			FONT_COLOR,		START_TIME,
			END_TIME,		NEW_CODE,		NEW_NAME,		NEW_DATE,		RES_CODE
			)
			VALUES
			(
			@EMP_CODE,		@SCH_TYPE,		@SCH_DATE,		@SUBJECT,		@CONTENTS,
			@SCH_GRADE,		@ALT_TIME,		@ALT_YN,		@FONT_COLOR,	@START_TIME,
			@END_TIME,		@USERID,		@USERNAME,		GETDATE(),		@RES_CODE
			)
		
			SELECT @TMP_SEQ = @@IDENTITY;
			UPDATE PRI_SCHEDULE SET PARENT_SEQ = @TMP_SEQ WHERE EMP_CODE = @EMP_CODE AND SEQ_NO = @TMP_SEQ;
		END 
		
	END
	ELSE
	BEGIN			
		
		SET @RPT_DAYCOUNT = (CASE @RPT_TYPE WHEN 1 THEN 1 WHEN 2 THEN 1 WHEN 3 THEN 7 ELSE 1 END);	--반복일수 계산		

		WHILE (@REPEATCOUNT > -1)
		BEGIN
			--print (@REPEATCOUNT)
			INSERT INTO PRI_SCHEDULE   --@SCH_DATE는 일정을 가져오는데 척도가 되므로 반복 일정의 경우 시작시간으로 설정함
			(
			EMP_CODE,		SCH_TYPE,		SCH_DATE,		SUBJECT,		CONTENTS,
			SCH_GRADE,		ALT_TIME,		ALT_YN,			FONT_COLOR,		START_TIME,
			END_TIME,		NEW_CODE,		NEW_NAME,		NEW_DATE,		PARENT_SEQ , RES_CODE
			)
			VALUES
			(
			@EMP_CODE,		@SCH_TYPE,		@START_TIME,	@SUBJECT,		@CONTENTS,
			@SCH_GRADE,		@ALT_TIME,		@ALT_YN,		@FONT_COLOR,	@START_TIME,
			@END_TIME,		@EMP_CODE,		@USERNAME,		GETDATE(),		@PARENT_SEQ	, @RES_CODE
			)
			
			IF @PARENT_SEQ = 0   --처음 업데이트의 경우 PARENT SEQ 넘버를 저장함
			BEGIN
				SELECT @PARENT_SEQ = @@IDENTITY;
				UPDATE PRI_SCHEDULE SET PARENT_SEQ = @PARENT_SEQ WHERE EMP_CODE = @EMP_CODE AND SEQ_NO = @PARENT_SEQ;

			END				
	
			IF @RPT_TYPE = 1 OR @RPT_TYPE = 2 OR @RPT_TYPE = 3  --반복 타입 1 : 1일 / 2:월~금 / 3:매주(+7)
			BEGIN
				IF @SCH_TYPE <> '0'     --시작일 종료일 1/7일++ (만약 @RPT_TYPE이 2이고 금요일이면 토/일은 건너뜀)
				BEGIN
					SET @END_TIME = DATEADD(DD,(	CASE @RPT_TYPE WHEN 2 THEN 
																			(CASE DATEPART(DW, @START_TIME) WHEN '6' THEN 3 ELSE @RPT_DAYCOUNT END
																			)ELSE @RPT_DAYCOUNT END),@END_TIME);	

					SET @START_TIME = DATEADD(DD,(	CASE @RPT_TYPE WHEN 2 THEN 
																			(CASE DATEPART(DW, @START_TIME) WHEN '6' THEN 3 ELSE @RPT_DAYCOUNT END
																			) ELSE @RPT_DAYCOUNT END),@START_TIME);					
				END
				
				SET @REPEATCOUNT = @REPEATCOUNT - (CASE @RPT_TYPE WHEN 2 THEN 
																			(CASE DATEPART(DW, @ALT_TIME) WHEN '6' THEN 3 ELSE @RPT_DAYCOUNT END
																			)ELSE @RPT_DAYCOUNT END) ;	
				
				IF @ALT_YN = 'T'  --알람 설정 1일++
				BEGIN
					SET @ALT_TIME = DATEADD(DD,(	CASE @RPT_TYPE WHEN 2 THEN 
																			(CASE DATEPART(DW, @ALT_TIME) WHEN '6' THEN 3 ELSE @RPT_DAYCOUNT END
																			)ELSE @RPT_DAYCOUNT END),@ALT_TIME);					
				END
			END
			ELSE IF @RPT_TYPE = 4   --반복 타입 월일 경우
			BEGIN
				IF @SCH_TYPE <> '0'     --시작일 종료일 월++
				BEGIN
					SET @START_TIME = DATEADD(m,@RPT_DAYCOUNT,@START_TIME);
					SET @END_TIME = DATEADD(m,@RPT_DAYCOUNT,@END_TIME);					
					SET @SCH_DATE = @START_TIME;
				END
				IF @ALT_YN = 'T'  --알람 설정 월++
				BEGIN
					SET @ALT_TIME = DATEADD(m,@RPT_DAYCOUNT,@ALT_TIME);					
				END
							
				SET @REPEATCOUNT = @REPEATCOUNT - 30;
			END		
		END
	END

END
GO
