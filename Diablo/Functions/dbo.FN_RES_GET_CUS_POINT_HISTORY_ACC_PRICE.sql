USE [Diablo]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*
 2011-12-19
포인트 사용내역의 적립 타입에 따른 금액 반환 


--  PARAM : @POINT_NO , @ACC_TYPE 
--  예제
	SELECT DBO.FN_RES_GET_CUS_POINT_HISTORY_ACC_PRICE(89812 , '1,2') 
	SELECT DBO.FN_RES_GET_CUS_POINT_HISTORY_ACC_PRICE(29742 , '1')

수정내역 
2013-05-13 최상위 적립 포인트 재귀 검색 
			- 포인트 양도 및 이동된것도 찾을수 있도록 (ORG_POINT_NO 가 없는것이 최상위)

2014-01-22 , 2013-01-01 ~ 2013-06-30 의 데이터는 전표 데이터로 나오도록 하기 
*/
CREATE FUNCTION [dbo].[FN_RES_GET_CUS_POINT_HISTORY_ACC_PRICE]
(
	@POINT_NO INT, @ACC_TYPE VARCHAR(50) 
)
RETURNS DECIMAL
AS
BEGIN


--declare @POINT_NO INT, @ACC_TYPE VARCHAR(50) 
--select  @POINT_NO = 89812 , @ACC_TYPE = '3'
	DECLARE @ACC_PRICE DECIMAL;
	BEGIN

		--2013-01-01 ~ 2013-06-30 
		IF( @POINT_NO BETWEEN 74745 AND  105963 )
		BEGIN 
			--**기존코드
			SELECT 
				@ACC_PRICE = ISNULL(SUM(A.POINT_PRICE), 0)
			FROM CUS_POINT_HISTORY_201306 A WITH(NOLOCK) 
				INNER JOIN CUS_POINT B WITH(NOLOCK)
					ON A.POINT_NO = B.POINT_NO 
			WHERE A.POINT_NO = @POINT_NO 
			AND A.ACC_TYPE IN ( 
				SELECT CONVERT(INT,DATA) FROM dbo.FN_SPLIT(@ACC_TYPE,',') )
			AND B.POINT_TYPE = 2  --사용만 
			--AND B.IS_CXL = 0 -- 취소 아닌것만 
		END 
		ELSE
		BEGIN
			--**기존코드
			SELECT 
				@ACC_PRICE = ISNULL(SUM(A.POINT_PRICE), 0)
			FROM CUS_POINT_HISTORY A WITH(NOLOCK) 
				INNER JOIN CUS_POINT B WITH(NOLOCK)
					ON A.POINT_NO = B.POINT_NO 
			WHERE A.POINT_NO = @POINT_NO 
			AND A.ACC_TYPE IN ( 
				SELECT CONVERT(INT,DATA) FROM dbo.FN_SPLIT(@ACC_TYPE,',') )
			AND B.POINT_TYPE = 2  --사용만 
			--AND B.IS_CXL = 0 -- 취소 아닌것만 
		END 

		
	END 

	--SELECT @ACC_PRICE 
	 
	RETURN (@ACC_PRICE)
END
GO
